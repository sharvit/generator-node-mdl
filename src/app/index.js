'use strict';

const path = require('path');
const Generator = require('yeoman-generator');
const camelCase = require('lodash.camelcase');
const kebabCase = require('lodash.kebabcase');
const chalk = require('chalk');
const commandExists = require('command-exists');
const findUp = require('find-up');
const makeDir = require('make-dir');

const github = require('./lib/github');
const npm = require('./lib/npm');

module.exports = class extends Generator {
  /*
    Run Loop
   */

  async prompting() {
    this.props = {};

    await this._promptGeneral();
    await this._promptGithub();
    await this._promptTravis();
    await this._promptNpm();
  }

  configuring() {
    if (path.basename(this.destinationRoot()) !== this.props.projectName) {
      return makeDir(this.props.projectName).then(path => {
        this.destinationRoot(path);
        this.log(`\nGenerating a new project in ${chalk.green(path)}\n`);
      });
    }
  }

  writing() {
    const templatesToCopy = [
      { templatePath: '_babelrc', destinationPath: '.babelrc' },
      { templatePath: '_editorconfig', destinationPath: '.editorconfig' },
      { templatePath: '_eslintignore', destinationPath: '.eslintignore' },
      { templatePath: '_eslintrc', destinationPath: '.eslintrc' },
      { templatePath: '_gitattributes', destinationPath: '.gitattributes' },
      { templatePath: '_gitignore', destinationPath: '.gitignore' },
      { templatePath: '_package.json', destinationPath: 'package.json' },
      { templatePath: 'license', destinationPath: 'license' },
      { templatePath: 'readme.md', destinationPath: 'readme.md' },
      { templatePath: 'src', destinationPath: 'src' },
    ];

    if (this.props.githubTemplates) {
      templatesToCopy.push(
        { templatePath: '_github', destinationPath: '.github' },
        { templatePath: 'other', destinationPath: 'other' },
        { templatePath: 'contributing.md', destinationPath: 'contributing.md' }
      );
    }

    if (this.props.travisCI) {
      templatesToCopy.push({
        templatePath: '_travis.yml',
        destinationPath: '.travis.yml',
      });
    }

    if (this.props.npmDeploy) {
      templatesToCopy.push({
        templatePath: '_npmignore',
        destinationPath: '.npmignore',
      });
    }

    templatesToCopy.forEach(({ templatePath, destinationPath }) =>
      this.fs.copyTpl(
        this.templatePath(templatePath),
        this.destinationPath(destinationPath),
        this.props
      )
    );
  }

  async install() {
    this._installNpmDeps();

    if (this.props.travisCI) {
      await this._installTravis();
    }
  }

  async end() {
    await this._removeYoRc();

    this._createGit();

    if (this.props.createGithubRepository) {
      const repository = await this._createGithubRepository();

      this.log('\n\n');
      this.log(`Repository created: ${repository.html_url}`);
    }
  }

  /*
    Private Methods
   */

  async _promptGeneral() {
    const answers = await this.prompt([
      {
        name: 'projectName',
        message: 'Project name',
        default: kebabCase(this.appname),
        filter: kebabCase,
      },
      {
        name: 'description',
        message: 'Description',
        default: 'Generated by `generator-node-mdl`',
        store: true,
      },
      {
        name: 'name',
        message: "Author's name",
        default: this.user.git.name(),
      },
      {
        name: 'email',
        message: "Author's email",
        default: this.user.git.email(),
      },
      {
        name: 'website',
        message: "Author's website",
        store: true,
      },
    ]);

    Object.assign(this.props, answers, {
      camelProject: camelCase(answers.projectName),
    });
  }

  async _promptGithub() {
    const answers = await this.prompt([
      {
        name: 'githubUsername',
        message: 'GitHub username',
        store: true,
      },
      {
        name: 'githubTemplates',
        message: 'Would you like to make it Github friendly for contributions?',
        type: 'confirm',
        default: true,
      },
      {
        name: 'createGithubRepository',
        message: 'Create a github repository?',
        type: 'confirm',
        default: true,
      },
    ]);

    Object.assign(this.props, answers, {
      repository: `${answers.githubUsername}/${this.props.projectName}`,
    });

    if (answers.createGithubRepository) {
      await this._loginToGithub();
    }
  }

  async _promptTravis() {
    const answers = await this.prompt([
      {
        name: 'travisCI',
        message: 'Give your project super prowers using Travis CI?',
        type: 'confirm',
        default: true,
        when: () => {
          this.log(
            '\nLearn how to use Travis CI: https://docs.travis-ci.com/user/tutorial/#to-get-started-with-travis-ci'
          );
          return true;
        },
      },
      {
        name: 'coveralls',
        message: 'Connect TravisCI to Coveralls?',
        type: 'confirm',
        default: true,
        when: ({ travisCI }) => {
          if (travisCI) {
            this.log('\nLearn how to use Coveralls: https://coveralls.io');
            return true;
          }

          return false;
        },
      },
    ]);

    Object.assign(this.props, answers, { coveralls: answers.coveralls });
  }

  async _promptNpm() {
    const answers = await this.prompt([
      {
        name: 'npmDeploy',
        message: 'Automatically deploy to npm using TravisCI?',
        type: 'confirm',
        default: true,
        when: () => {
          if (this.props.travisCI) {
            this.log('\nNeed to have an npm account: https://www.npmjs.com/');
            return true;
          }

          return false;
        },
      },
    ]);

    Object.assign(this.props, {
      npmDeploy: answers.npmDeploy,
    });

    if (this.props.npmDeploy) {
      await this._loginToNpm();
    }
  }

  _promptNpmLogin() {
    return this.prompt([
      {
        name: 'npmUsername',
        message: 'Your npm username:',
        store: true,
      },
      {
        name: 'npmPassword',
        message: 'Your npm password:',
        type: 'password',
      },
    ]);
  }

  _promptGithubPassword() {
    const { githubUsername } = this.props;

    return this.prompt([
      {
        name: 'githubPassword',
        message: `Enter you github password for ${githubUsername}:`,
        type: 'password',
      },
    ]);
  }

  async _loginToNpm() {
    const { npmUsername, npmPassword } = await this._promptNpmLogin();

    // generate npm-token
    const { token } = await npm.login({
      username: npmUsername,
      password: npmPassword,
    });

    Object.assign(this.props, {
      npmToken: token,
    });
  }

  async _loginToGithub() {
    const { githubUsername } = this.props;
    const { githubPassword } = await this._promptGithubPassword();

    github.login({
      username: githubUsername,
      password: githubPassword,
    });
  }

  _installTravis() {
    if (process.env.NODE_ENV === 'test') {
      return;
    }
    const { repository, npmDeploy, npmToken } = this.props;

    this.spawnCommandSync('gem', [
      'install',
      'travis',
      '--no-ri',
      '--no-rdoc',
      '--quiet',
    ]);
    this.spawnCommandSync('travis', ['login', '--auto']);
    this.spawnCommandSync('travis', ['enable', '-r', repository]);

    if (npmDeploy) {
      this.spawnCommandSync('travis', [
        'env',
        'set',
        'NPM_TOKEN',
        npmToken,
        '-r',
        repository,
      ]);
    }
  }

  _installNpmDeps() {
    const hasYarn = commandExists.sync('yarn');

    this.installDependencies({
      bower: false,
      npm: !hasYarn,
      yarn: hasYarn,
    });
  }

  _createGit() {
    const { repository } = this.props;

    this.spawnCommandSync('git', ['init', '--quiet']);
    this.spawnCommandSync('git', [
      'remote',
      'add',
      'origin',
      `git@github.com:${repository}.git`,
    ]);
    this.spawnCommandSync('git', ['add', '.']);
    this.spawnCommandSync('git', [
      'commit',
      '-m',
      'Generated by generator-node-mdl ðŸ”¥',
      '--quiet',
    ]);
  }

  async _removeYoRc() {
    return findUp('.yo-rc.json').then(res => {
      if (res) {
        this.fs.delete(res);
        return new Promise((resolve, reject) => {
          this.fs.commit(() => resolve());
        });
      }
    });
  }

  async _createGithubRepository() {
    const { data } = await github.createRepository({
      name: this.props.projectName,
      description: this.props.description,
    });

    return data;
  }
};
